---
title: Standardized Work
---

I aimed to standardize the work for these reasons
1. Create a value stream map through the organic evolution of the documentation.
2. Use as a baseline for Kaizens.
3. Stabilize the system of work by reducing the overburden through the adoption of standards.

Standardising the work was an informal way of developing a Value Stream Map. 
I tried to gradually understand the whole system of work through informal conversations. 
First we documented the current conditions, then we improved upon it.
Then if someone else wanted to try an improvement, they had to check if they were working according to the standard.
If they weren't they first had to change to the standard because typically that standard would have already been a better practice.
What I didn't do is blindly document everything or try to map everything.
How much did we document, like to what level of detail?
There was enough detail such that individuals could follow the improvement journey of their peers at their own pace with minimal (not none) guidance. 
They also had to be short enough that one could make the change to their way of working whenever they had down time for an hour or so.
An example is a simple checklist of 10 steps to installing Eclipse. 

In addition to organically developing the VSM, another use for standardising the work was to compare improvements. 
The documentation also had to have enough information to compare improvements.
Each time someone wanted to change something, they needed to make a hypotheses that compared their idea to the standard. 
Without a standard, it would be like running a test without a baseline which they understood.

Though there were standards, they were very loosely followed or there was almost a different way of working for each tester. 
I think this happened because everyone just got so busy that there wasn't enough time for coaching or peer-reviews etc.
One challenge in getting folks to adopt a standard that requires so much details is fear.  
I think folks kept the test cases light on details to protect their job-security.  
That is, if nobody can read their work, then nobody can replace them.  
By showing the team that the test cases written in the DSL can be automatically converted into automation, I feel it helped reduce the resistance because they learnt new skills.

With the exception of the COBOL testers most of the testers didn't write test cases in a way that another tester could understand and execute their tests.  
Understanding the tests would make it easier for the testers to practice pairing, teaming, mobbing or swarming and therefore reduce the overburden.
In the COBOL testing team, if someone finished their work for the release earlier, they could help others who were falling behind.
This was made possible by having tests cases so clear and so void of assumed knowledge that code generation from it was trivial.
I gradually steered the rest of the team to adopt such a standard and that's how we got the grammar for the [ubiquitous language](/demingdriventesting/about).

