---
title: Standardized Work
---

Before changing anything by making it faster or eliminating it, we needed a standard. 
Standardising the work was an informal way of developing a Value Stream Map. 
I tried to gradually understand the whole system of work through informal conversations. 
Though there were standards, they were very loosely followed or there was almost a different way of working for each tester. 
I think this happened because everyone just got so busy that there wasn't enough time for coaching or peer-reviews etc.

As we made kaizens, we documented them as they became part of the new standard. 
First we documented the current conditions, then we improved upon it.
Then if someone else wanted to try the new improvement, they had to check if they were working according to the standard.
If they weren't they first had to change to the standard because typically that standard would have already been a better practice.
What I didn't do is blindly document everything or try to map everything.
Instead the documentation developed organically as we improved.

How much did we document, like to what level of detail?
There was enough detail such that individuals could follow the improvement journey of their peers at their own pace with minimal (not none) guidance. 
They also had to be short enough that one could make the change to their way of working whenever they had down time for an hour or so.
An example is a simple checklist of 10 steps to installing Eclipse. 
In addition to organically developing the VSM, another use for standardising the work was to compare improvements. 
The documentation also had to have enough information to compare improvements.
Each time someone wanted to change something, they needed to make a hypotheses that compared their idea to the standard. 
Without a standard, it would be like running a test without a baseline which they understood.

One standard that already existed was around how the COBOL testers wrote their test cases.
The idea was that if someone finished their work for the release earlier, they could help others who were falling behind.
This was made possible by having tests cases so clear and so void of assumed knowledge that code generation from it was trivial.
I gradually steered the rest of the team to adopt such a standard and that's how we got the grammar for the ubiquitous language.
